#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//This code will introduce you to the one of the three motors used in FTC competition: The TETRIX motor.
//In addition, it will show how to use encoders for this type of motor.

//This code requires basic knowledge of ROBOTC syntax, so if you have trouble, ask an older programmer.
//To see it in action, attach a motor controller to Sensor Port 1, and attach a motor to the motor 1 connectors.
//In addition, for encoders, you must have a TETRIX motor encoder attached to the motor you are using.

//This code is not intended for direct copy-paste, but feel free to use the elements you find from it to make your own programs.

task main()
{
	//TETRIX motors are attached to motor controllers. Two can be attached per motor.
	//All motors after motorC (i.e. motorD, motorE, motorF, etc.) will be TETRIX motors.
	//You will probably only have to deal with motors up to motorG, but know that you can have more.
	//For this code, we will use motorD.

	//Let's begin by making the motor run.
	//To make a TETRIX motor move, set its speed to a number between 0 and 100.
	//At 100, the motor will turn at 152 rpm, and can withstand 300 oz-in. of torque.
	motor[motorD] = 50;

	//At this point, the motor will run forever. To make it stop, use the following code.

	wait1Msec(5000); //This line will tell the computer to wait 5000 milliseconds (5 seconds) before continuing.

	motor[motorD] = 0; //This line stops the motor.

	//Next, let's look at encoders.
	//TETRIX motor encoders have to be enabled in "Motors and Sensors Setup", before using them in your code.
	//They allow the robot to track how many degrees of rotation it has made.
	//Where the NXT encoders use 360 ticks per rotation, the TETRIX encoders use 1440.
	//This allows for higher accuracy, to the 1/4 degree.

	//Always reset the nMotorEncoder value before running your code.
	nMotorEncoder[motorD] = 0;

	//To make the motor run for a certain amount of rotations, multiply (desired # rotations) * 1440.

	//For instance, to make your motor turn for 3 rotations:

	motor[motorD] = 50; //Start the motor

	while(nMotorEncoder[motorD] < 4320) {
		//This loop keeps the reader here until the target is reached
	}

	motor[motorD] = 0; //Once the 3-rotation limit has been reached, stop the robot.

	//However, a more accurate method of targetting encoders is the nMotorEncoderTarget function.

	nMotorEncoder[motorA] = 0;

	nMotorEncoderTarget[motorD] = 1440; //This tells the computer to rotate the motor until it reaches 1 rotation.
	//This program is a bit more accurate, as it will have the robot slow down as it nears its target.

	//It is used in conjunction with the nMotorRunState variable.
	//This variable has three values: runStateRunning, runStateHoldPosition, and runStateIdle
	//runStateRunning occurs when the robot is approaching its target at normal speed.
	//runStateHoldPosition occurs when the robot is slowing down to hit the target accurately.
	//runStateIdle occurs when the robot has stopped.

	motor[motorD] = 50;

	//The following code is used to protect the motor by stopping it completely once its target is reached.

	while(nMotorRunState[motorD] != runStateIdle) {
		//This loop keeps the robot running until the robot has reached its target.
	}
	motor[motorD] = 0; //Turning off the motor preserves it, as it won't be running while idle.

	//That's all you should need for TETRIX motors. For more information, go to
	//http://www.education.rec.ri.cmu.edu/previews/robot_c_products/teaching_rc_tetrix_preview/tetrix_sensing/documents/TETRIXSensing_printable.pdf
}
